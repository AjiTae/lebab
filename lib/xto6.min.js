/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var fs = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var merge = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"lodash/object/merge.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var codeGenerator = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"escodegen\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var astGenerator = _interopRequire(__webpack_require__(1));

	// Transformers

	var classTransformation = _interopRequire(__webpack_require__(2));

	var templateStringTransformation = _interopRequire(__webpack_require__(3));

	var arrowFunctionTransformation = _interopRequire(__webpack_require__(4));

	var Transformer = (function () {

	  /**
	   * @constructor
	   */

	  function Transformer() {
	    var options = arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Transformer);

	    this.ast = {};
	    this.options = merge(this.constructor.defaultOptions, options);
	    this.transformations = [];

	    this.prepareTransformations();
	  }

	  _createClass(Transformer, {
	    prepareTransformations: {

	      /**
	       * Prepare transformations array by give options
	       */

	      value: function prepareTransformations() {
	        var _this = this;

	        var shouldTransform = function (key) {
	          return typeof _this.options.transformers[key] !== "undefined" && _this.options.transformers[key];
	        };

	        var doTransform = function (key, transformation) {
	          if (shouldTransform(key)) {
	            _this.transformations.push(transformation);
	          }
	        };

	        doTransform("classes", classTransformation);
	        doTransform("stringTemplates", templateStringTransformation);
	        doTransform("arrowFunctions", arrowFunctionTransformation);
	      }
	    },
	    readFile: {

	      /**
	       * Prepare the abstract syntax tree for given file
	       *
	       * @param filename
	       */

	      value: function readFile(filename) {

	        this.ast = astGenerator.readFile(filename, {
	          sync: true,
	          ecmaVersion: 6
	        });
	      }
	    },
	    read: {

	      /**
	       * Prepare an abstract syntax tree for given code in string
	       *
	       * @param string
	       */

	      value: function read(string) {

	        this.ast = astGenerator.read(string, this.options);
	      }
	    },
	    applyTransformation: {

	      /**
	       * Apply a transformation on the AST
	       *
	       * @param transformation
	       */

	      value: function applyTransformation(transformation) {

	        transformation(this.ast);
	      }
	    },
	    applyTransformations: {

	      /**
	       * Apply All transformations
	       */

	      value: function applyTransformations() {

	        for (var i = 0; i < this.transformations.length; i++) {
	          var transformation = this.transformations[i];
	          this.applyTransformation(transformation);
	        }
	      }
	    },
	    out: {

	      /**
	       * Returns the code string
	       *
	       * @returns {Object}
	       */

	      value: function out() {
	        return codeGenerator.generate(this.ast);
	      }
	    },
	    writeFile: {

	      /**
	       * Writes the code on file
	       *
	       * @param filename
	       * @param callback
	       */

	      value: function writeFile(filename, callback) {

	        var code = this.out();

	        if (typeof callback === "function") {
	          fs.writeFile(filename, code, callback);
	        } else {
	          fs.writeFileSync(filename, code);
	        }
	      }
	    }
	  });

	  return Transformer;
	})();

	module.exports = Transformer;

	Transformer.defaultOptions = {
	  transformers: {
	    classes: true,
	    stringTemplates: true,
	    arrowFunctions: true
	  }
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	/**
	 * This function reads a js file and transforms it into AST
	 *
	 * @author Mohamad Mohebifar
	 * @param file
	 * @param options
	 * @returns {Object}
	 */
	exports.readFile = readFile;

	/**
	 * This function reads a js string and transforms it into AST
	 *
	 * @author Mohamad Mohebifar
	 * @param js
	 * @param options
	 * @returns {Object}
	 */
	exports.read = read;
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var acorn = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"acorn\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var fs = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var coffee = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"coffee-script\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	function readFile(file, options) {
	  var _this = this;

	  if (typeof options.coffee === "undefined") {
	    options.coffee = /\.coffee$/.test(file);
	  }

	  if (options.sync) {
	    var js = fs.readFileSync(file);
	    return this.read(js, options);
	  } else {
	    fs.readFile(file, function (js) {
	      if (options.callback) {
	        options.callback(_this.read(js, options));
	      }
	    });
	  }
	}

	function read(js, options) {

	  if (options.coffee) {
	    js = coffee.compile(js);
	  }

	  return acorn.parse(js, options);
	}

	exports["default"] = {
	  read: read,
	  readFile: readFile
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var estraverse = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"estraverse\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var utils = _interopRequire(__webpack_require__(16));

	var MethodDefinition = _interopRequire(__webpack_require__(5));

	var ClassBody = _interopRequire(__webpack_require__(6));

	var ClassDeclaration = _interopRequire(__webpack_require__(7));

	var FunctionExpression = _interopRequire(__webpack_require__(8));

	var Identifier = _interopRequire(__webpack_require__(9));

	var ThisExpression = _interopRequire(__webpack_require__(10));

	var MemberExpression = _interopRequire(__webpack_require__(11));

	var CallExpression = _interopRequire(__webpack_require__(12));

	var ReturnStatement = _interopRequire(__webpack_require__(13));

	module.exports = function (ast) {
	  estraverse.traverse(ast, {
	    enter: functionDetector
	  });

	  estraverse.traverse(ast, {
	    enter: classMaker
	  });

	  estraverse.replace(ast, {
	    enter: classReplacement
	  });
	};

	var functions = [];

	function createClass(_function) {
	  if (typeof _function["class"] === "undefined") {
	    var createdClass = new ClassDeclaration();
	    createdClass.name = _function.id.name;

	    var _constructor = new MethodDefinition();
	    _constructor.name = "constructor";
	    _constructor.body = _function.node.body;

	    _function["class"] = createdClass;
	    _function.node._class = createdClass;

	    createdClass.body.addMethod(_constructor, true);
	  }
	}

	function functionDetector(node, parent) {

	  if (node.type === "FunctionDeclaration") {
	    var id = node.id;
	    functions.push({
	      id: id,
	      parent: parent,
	      node: node
	    });
	  } else if (node.type === "VariableDeclarator" && node.init && node.init.type === "FunctionExpression") {
	    parent._replace = node.init;
	    var id = node.id;
	    functions.push({
	      id: id,
	      parent: parent,
	      node: node.init
	    });
	  }
	}

	function classMaker(node, parent) {

	  if (node.type === "AssignmentExpression") {

	    if (node.left.object && node.left.object.property && node.left.object.property.name === "prototype") {

	      var functionName = node.left.object.object.name;

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = functions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var _function = _step.value;

	          if (_function.id.name === functionName) {
	            createClass(_function);

	            var method = node.right;
	            var createdMethod = new MethodDefinition();

	            if (method.type === "Identifier") {

	              createdMethod.body = new ReturnStatement(new CallExpression(new MemberExpression(node.right, new Identifier("apply")), [new ThisExpression(), new Identifier("arguments")]));
	            } else {
	              createdMethod.body = method.body;
	              createdMethod.params = method.params;
	            }

	            createdMethod.name = node.left.property.name;

	            _function["class"].body.addMethod(createdMethod);

	            parent._remove = true;

	            this.skip();
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator["return"]) {
	            _iterator["return"]();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  } else if (node.type === "CallExpression" && node.callee && node.callee.type === "MemberExpression" && node.callee.object.name === "Object" && node.callee.property.name === "defineProperty" && node.arguments[0].type === "MemberExpression" && node.arguments[0].property.name === "prototype" && node.arguments[1].type === "Literal" && node.arguments[2].type === "ObjectExpression") {

	    var functionName = node.arguments[0].object.name;

	    for (var i = 0; i < functions.length; i++) {
	      var _function = functions[i];

	      if (_function.id.name === functionName) {
	        createClass(_function);
	        var properties = node.arguments[2].properties;

	        for (var j = 0; j < properties.length; j++) {
	          var property = properties[j];

	          if (property.key.name !== "get" && property.key.name !== "set") {
	            continue;
	          }

	          var createdMethod = new MethodDefinition();

	          createdMethod.body = property.value.body;
	          createdMethod.params = property.value.params;
	          createdMethod.name = node.arguments[1].value;
	          createdMethod.kind = property.key.name;

	          _function["class"].body.addMethod(createdMethod);
	        }

	        parent._remove = true;

	        this.skip();
	      }
	    }
	  }
	}

	function classReplacement(node) {
	  if (node._class) {
	    return node._class;
	  } else if (node._remove) {
	    this.remove();
	  } else if (node._replace) {
	    return node._replace._class;
	  }
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var estraverse = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"estraverse\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var esutils = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"esutils/lib/ast.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var TemplateLiteral = _interopRequire(__webpack_require__(14));

	var _ = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"lodash/index.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	module.exports = function (ast) {
	  estraverse.replace(ast, {
	    enter: traverser
	  });
	};

	var operands, hasString, hasExpression;

	function traverser(node) {
	  if (node.type === "BinaryExpression" && node.operator === "+") {

	    operands = [];
	    hasString = false;

	    estraverse.traverse(node, {
	      enter: detector
	    });

	    if (hasString && hasExpression) {
	      operands = _(operands).reverse().value();

	      var templateString = new TemplateLiteral();
	      templateString.createFromArray(operands);
	      this.skip();
	      return templateString;
	    }
	  }
	}

	function detector(node) {

	  if (isBinaryExpression(node) && node.operator === "+") {
	    var left = node.left;
	    var right = node.right;

	    addOperand(right);

	    if (!isBinaryExpression(left)) {
	      addOperand(left);

	      this.skip();
	    }
	  } else if (isBinaryExpression(node)) {
	    addOperand(node);
	    this.skip();
	  }
	}

	function addOperand(node) {
	  operands.push(node);

	  if (isString(node)) {
	    hasString = true;
	  }

	  if (esutils.isExpression(node) && node.type !== "Literal") {
	    hasExpression = true;
	  }
	}

	function isLiteral(node) {
	  return /Literal/.test(node.type);
	}

	function isString(node) {
	  return isLiteral(node) && typeof node.value === "string";
	}

	function isBinaryExpression(node) {
	  return /BinaryExpression/.test(node.type);
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var estraverse = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"estraverse\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var utils = _interopRequire(__webpack_require__(16));

	var ArrowExpression = _interopRequire(__webpack_require__(15));

	var ThisExpression = _interopRequire(__webpack_require__(10));

	var _ = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"lodash\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	module.exports = function (ast) {
	  estraverse.replace(ast, {
	    enter: callBackToArrow
	  });
	};

	function callBackToArrow(node, parent) {
	  if (node.type === "FunctionExpression" && parent.type === "CallExpression" && !hasThis(node)) {
	    var arrow = new ArrowExpression();
	    arrow.body = node.body;
	    arrow.params = node.params;
	    arrow.rest = node.rest;
	    arrow.defaults = node.defaults;
	    arrow.generator = node.generator;
	    arrow.id = node.id;

	    return arrow;
	  }
	}

	var objectProps = ["body", "expression", "left", "right", "object"];

	function hasThis(node) {
	  if (_.isArray(node)) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = node[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var sub = _step.value;

	        var result = hasThis(sub);
	        if (result) return result;
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator["return"]) {
	          _iterator["return"]();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return false;
	  }
	  if (node.type === "ThisExpression") {
	    return true;
	  }var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = objectProps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var prop = _step2.value;

	      if (node[prop]) return hasThis(node[prop]);
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
	        _iterator2["return"]();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  return false;
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var FunctionExpression = _interopRequire(__webpack_require__(8));

	var Identifier = _interopRequire(__webpack_require__(9));

	var BlockStatement = _interopRequire(__webpack_require__(18));

	/**
	 * The class to define the MethodDefinition syntax
	 *
	 * @class MethodDefinition
	 */

	var MethodDefinition = (function (_BaseSyntax) {

	  /**
	   * Create a method for a class
	   *
	   * @constructor
	   * @param {ClassDeclaration} _class
	   */

	  function MethodDefinition(_class) {
	    _classCallCheck(this, MethodDefinition);

	    _get(Object.getPrototypeOf(MethodDefinition.prototype), "constructor", this).call(this, "MethodDefinition");

	    this.key = new Identifier();
	    this["class"] = _class;
	    this["static"] = false;
	    this.computed = false;
	    this.kind = "";
	    this.value = new FunctionExpression();
	  }

	  _inherits(MethodDefinition, _BaseSyntax);

	  _createClass(MethodDefinition, {
	    name: {
	      set: function (name) {
	        this.key.name = name;
	      },
	      get: function () {
	        return this.key.name;
	      }
	    },
	    body: {
	      set: function (body) {
	        if (BlockStatement.is(body)) {
	          this.value.body = body;
	        } else if (body instanceof Array) {
	          this.value.body.body = body;
	        } else {
	          this.value.body.body = [body];
	        }
	      },
	      get: function () {
	        return this.value.body;
	      }
	    },
	    params: {
	      set: function (params) {
	        this.value.params = params;
	      },
	      get: function () {
	        return this.value.params;
	      }
	    }
	  });

	  return MethodDefinition;
	})(BaseSyntax);

	module.exports = MethodDefinition;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var MethodDefinition = _interopRequire(__webpack_require__(5));

	/**
	 * The class to define the ClassBody syntax
	 *
	 * @class ClassBody
	 */

	var ClassBody = (function (_BaseSyntax) {

	  /**
	   * The constructor of ClassBody
	   *
	   * @constructor
	   */

	  function ClassBody() {
	    _classCallCheck(this, ClassBody);

	    _get(Object.getPrototypeOf(ClassBody.prototype), "constructor", this).call(this, "ClassBody");
	    this.body = [];
	  }

	  _inherits(ClassBody, _BaseSyntax);

	  _createClass(ClassBody, {
	    addMethod: {
	      value: function addMethod(method, prepend) {
	        if (method instanceof MethodDefinition) {

	          if (prepend) {
	            this.body.unshift(method);
	          } else {
	            this.body.push(method);
	          }
	        }
	      }
	    }
	  });

	  return ClassBody;
	})(BaseSyntax);

	module.exports = ClassBody;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var ClassBody = _interopRequire(__webpack_require__(6));

	var Identifier = _interopRequire(__webpack_require__(9));

	/**
	 * The class to define the ClassDeclaration syntax
	 *
	 * @class ClassDeclaration
	 */

	var ClassDeclaration = (function (_BaseSyntax) {

	  /**
	   * The constructor of ClassDeclaration
	   *
	   * @constructor
	   */

	  function ClassDeclaration() {
	    _classCallCheck(this, ClassDeclaration);

	    _get(Object.getPrototypeOf(ClassDeclaration.prototype), "constructor", this).call(this, "ClassDeclaration");

	    this.body = new ClassBody();
	    this.superClass = null;
	    this.id = new Identifier();
	  }

	  _inherits(ClassDeclaration, _BaseSyntax);

	  _createClass(ClassDeclaration, {
	    name: {
	      set: function (name) {
	        this.id.name = name;
	      },
	      get: function () {
	        return this.id.name;
	      }
	    }
	  });

	  return ClassDeclaration;
	})(BaseSyntax);

	module.exports = ClassDeclaration;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var BlockStatement = _interopRequire(__webpack_require__(18));

	/**
	 * The class to define the FunctionExpression syntax
	 *
	 * @class FunctionExpression
	 */

	var FunctionExpression = (function (_BaseSyntax) {

	  /**
	   * The constructor of FunctionExpression
	   *
	   * @constructor
	   */

	  function FunctionExpression() {
	    _classCallCheck(this, FunctionExpression);

	    _get(Object.getPrototypeOf(FunctionExpression.prototype), "constructor", this).call(this, "FunctionExpression");

	    this.body = new BlockStatement();
	    this.params = [];
	    this.defaults = [];
	    this.rest = null;
	    this.generator = false;
	    this.id = null;
	  }

	  _inherits(FunctionExpression, _BaseSyntax);

	  _createClass(FunctionExpression, {
	    appendToBody: {
	      value: function appendToBody(statement) {
	        this.body.appendToBody(statement);
	      }
	    }
	  });

	  return FunctionExpression;
	})(BaseSyntax);

	module.exports = FunctionExpression;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the Identifier syntax
	 *
	 * @class Identifier
	 */

	var Identifier = (function (_BaseSyntax) {

	  /**
	   * The constructor of Identifier
	   *
	   * @constructor
	   */

	  function Identifier(name) {
	    _classCallCheck(this, Identifier);

	    _get(Object.getPrototypeOf(Identifier.prototype), "constructor", this).call(this, "Identifier");

	    this.name = name;
	  }

	  _inherits(Identifier, _BaseSyntax);

	  return Identifier;
	})(BaseSyntax);

	module.exports = Identifier;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the ThisExpression syntax
	 *
	 * @class ThisExpression
	 */

	var ThisExpression = (function (_BaseSyntax) {

	  /**
	   * The constructor of ThisExpression
	   *
	   * @constructor
	   */

	  function ThisExpression() {
	    _classCallCheck(this, ThisExpression);

	    _get(Object.getPrototypeOf(ThisExpression.prototype), "constructor", this).call(this, "ThisExpression");
	  }

	  _inherits(ThisExpression, _BaseSyntax);

	  return ThisExpression;
	})(BaseSyntax);

	module.exports = ThisExpression;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the MemberExpression syntax
	 *
	 * @class MemberExpression
	 */

	var MemberExpression = (function (_BaseSyntax) {

	  /**
	   * The constructor of MemberExpression
	   *
	   * @constructor
	   */

	  function MemberExpression(object, property) {
	    _classCallCheck(this, MemberExpression);

	    _get(Object.getPrototypeOf(MemberExpression.prototype), "constructor", this).call(this, "MemberExpression");
	    this.object = object;
	    this.property = property;
	  }

	  _inherits(MemberExpression, _BaseSyntax);

	  return MemberExpression;
	})(BaseSyntax);

	module.exports = MemberExpression;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the CallExpression syntax
	 *
	 * @class CallExpression
	 */

	var CallExpression = (function (_BaseSyntax) {

	  /**
	   * The constructor of CallExpression
	   *
	   * @constructor
	   */

	  function CallExpression(callee, args) {
	    _classCallCheck(this, CallExpression);

	    _get(Object.getPrototypeOf(CallExpression.prototype), "constructor", this).call(this, "CallExpression");
	    this.callee = callee;
	    this.arguments = args;
	  }

	  _inherits(CallExpression, _BaseSyntax);

	  return CallExpression;
	})(BaseSyntax);

	module.exports = CallExpression;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the ReturnStatement syntax
	 *
	 * @class FunctionExpression
	 */

	var ReturnStatement = (function (_BaseSyntax) {

	  /**
	   * The constructor of ReturnStatement
	   *
	   * @constructor
	   */

	  function ReturnStatement(argument) {
	    _classCallCheck(this, ReturnStatement);

	    _get(Object.getPrototypeOf(ReturnStatement.prototype), "constructor", this).call(this, "ReturnStatement");

	    this.argument = argument;
	  }

	  _inherits(ReturnStatement, _BaseSyntax);

	  return ReturnStatement;
	})(BaseSyntax);

	module.exports = ReturnStatement;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var TemplateElement = _interopRequire(__webpack_require__(19));

	var esutils = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"esutils/lib/ast.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	var utils = _interopRequire(__webpack_require__(16));

	/**
	 * The class to define the TemplateLiteral syntax
	 *
	 * @class TemplateLiteral
	 */

	var TemplateLiteral = (function (_BaseSyntax) {

	  /**
	   * Create a template literal
	   *
	   * @constructor
	   */

	  function TemplateLiteral() {
	    _classCallCheck(this, TemplateLiteral);

	    _get(Object.getPrototypeOf(TemplateLiteral.prototype), "constructor", this).call(this, "TemplateLiteral");

	    this.expressions = [];
	    this.quasis = [];
	  }

	  _inherits(TemplateLiteral, _BaseSyntax);

	  _createClass(TemplateLiteral, {
	    createFromArray: {
	      value: function createFromArray(parts) {
	        var isString = function (node) {
	          return typeof node !== "undefined" && node.type === "Literal" && typeof node.value === "string";
	        };

	        var isExpression = function (node) {
	          return typeof node !== "undefined" && esutils.isExpression(node);
	        };

	        for (var i = 0; i < parts.length; i++) {
	          var curr = parts[i];

	          //console.log(curr);

	          if (isString(curr)) {
	            var element = new TemplateElement();
	            curr = curr.value;

	            while (isString(parts[++i])) {
	              curr += parts[i].value;
	            }

	            element.setValue(curr);
	            this.quasis.push(element);

	            i--;
	          } else {
	            if (i === 0) {
	              var element = new TemplateElement();
	              element.setValue("");
	              this.quasis.push(element);
	            }

	            if (typeof parts[i + 1] === "undefined") {
	              var element = new TemplateElement();
	              element.tail = true;
	              this.quasis.push(element);
	            } else if (parts[i + 1].type !== "Literal") {
	              var element = new TemplateElement();
	              this.quasis.push(element);
	              //console.log(parts[i + 1]);
	            }

	            this.expressions.push(curr);
	          }
	        }

	        //console.log(JSON.stringify(this));
	      }
	    }
	  });

	  return TemplateLiteral;
	})(BaseSyntax);

	module.exports = TemplateLiteral;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var BlockStatement = _interopRequire(__webpack_require__(18));

	/**
	 * The class to define the ArrowExpression syntax
	 *
	 * @class ArrowExpression
	 */

	var ArrowExpression = (function (_BaseSyntax) {

	  /**
	   * The constructor of ArrowExpression
	   *
	   * @constructor
	   */

	  function ArrowExpression() {
	    _classCallCheck(this, ArrowExpression);

	    _get(Object.getPrototypeOf(ArrowExpression.prototype), "constructor", this).call(this, "ArrowFunctionExpression");

	    this.body = new BlockStatement();
	    this.params = [];
	    this.defaults = [];
	    this.rest = null;
	    this.generator = false;
	    this.id = null;
	  }

	  _inherits(ArrowExpression, _BaseSyntax);

	  _createClass(ArrowExpression, {
	    appendToBody: {
	      value: function appendToBody(statement) {
	        this.body.appendToBody(statement);
	      }
	    }
	  });

	  return ArrowExpression;
	})(BaseSyntax);

	module.exports = ArrowExpression;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(20);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(22);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	/**
	 * @abstract BaseSyntax
	 */

	var BaseSyntax =

	/**
	 * The constructor of BaseSyntax
	 *
	 * @param {String} type
	 */
	function BaseSyntax(type) {
	  _classCallCheck(this, BaseSyntax);

	  this.type = type;
	};

	module.exports = BaseSyntax;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	/**
	 * The class to define the BlockStatement syntax
	 *
	 * @class BlockStatement
	 */

	var BlockStatement = (function (_BaseSyntax) {

	  /**
	   * The constructor of BlockStatement
	   *
	   * @constructor
	   */

	  function BlockStatement(callee, args) {
	    _classCallCheck(this, BlockStatement);

	    _get(Object.getPrototypeOf(BlockStatement.prototype), "constructor", this).call(this, "BlockStatement");
	    this.body = [];
	  }

	  _inherits(BlockStatement, _BaseSyntax);

	  _createClass(BlockStatement, {
	    appendToBody: {
	      value: function appendToBody(statement) {
	        this.body.push(statement);
	      }
	    }
	  }, {
	    is: {

	      /**
	       * Check if an object is representing a BlockStatement
	       *
	       * @param object
	       * @returns {boolean}
	       */

	      value: function is(object) {
	        return typeof object === "object" && typeof object.type !== "undefined" && object.type === "BlockStatement";
	      }
	    }
	  });

	  return BlockStatement;
	})(BaseSyntax);

	module.exports = BlockStatement;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var BaseSyntax = _interopRequire(__webpack_require__(17));

	var esutils = _interopRequire(__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"esutils/lib/ast.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())));

	/**
	 * The class to define the TemplateElement syntax
	 *
	 * @class TemplateElement
	 */

	var TemplateElement = (function (_BaseSyntax) {

	  /**
	   * Create a template literal
	   *
	   * @constructor
	   */

	  function TemplateElement() {
	    _classCallCheck(this, TemplateElement);

	    _get(Object.getPrototypeOf(TemplateElement.prototype), "constructor", this).call(this, "TemplateElement");

	    this.value = { raw: "", cooked: "" };
	    this.tail = false;
	  }

	  _inherits(TemplateElement, _BaseSyntax);

	  _createClass(TemplateElement, {
	    setValue: {
	      value: function setValue(value) {
	        this.value.raw = value;
	        this.value.cooked = value;
	      }
	    },
	    setRaw: {
	      value: function setRaw(raw) {
	        this.value.raw = raw;
	      }
	    },
	    setCooked: {
	      value: function setCooked(cooked) {
	        this.value.cooked = cooked;
	      }
	    }
	  });

	  return TemplateElement;
	})(BaseSyntax);

	module.exports = TemplateElement;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }
/******/ ]);